// This file is autogenerated.
// Take a look at `Preprocessor` target in RxSwift project 
//
//  CombineLatest.tt.swift
//  RxSwift
//
//  Created by Krunoslav Zaher on 4/22/15.
//  Copyright (c) 2015 Krunoslav Zaher. All rights reserved.
//

import Foundation



class CombineLatestSink2_<T1, T2, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest2<T1, T2, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 2, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(2)

        for i in 0 ..< 2 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value)
    }
}

class CombineLatest2<T1, T2, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink2_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}



class CombineLatestSink3_<T1, T2, T3, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest3<T1, T2, T3, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil
    var observer3: CombineLatestObserver<T3>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 3, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(3)

        for i in 0 ..< 3 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])
        observer3 = CombineLatestObserver(parent: self, index: 3, this: subscriptions[3])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))
        subscriptions[3].setDisposable(*parent.source3.subscribeSafe(ObserverOf(observer3)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value, observer3.value)
    }
}

class CombineLatest3<T1, T2, T3, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2, T3) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>
    let source3: Observable<T3>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink3_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}



class CombineLatestSink4_<T1, T2, T3, T4, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest4<T1, T2, T3, T4, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil
    var observer3: CombineLatestObserver<T3>! = nil
    var observer4: CombineLatestObserver<T4>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 4, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(4)

        for i in 0 ..< 4 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])
        observer3 = CombineLatestObserver(parent: self, index: 3, this: subscriptions[3])
        observer4 = CombineLatestObserver(parent: self, index: 4, this: subscriptions[4])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))
        subscriptions[3].setDisposable(*parent.source3.subscribeSafe(ObserverOf(observer3)))
        subscriptions[4].setDisposable(*parent.source4.subscribeSafe(ObserverOf(observer4)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value, observer3.value, observer4.value)
    }
}

class CombineLatest4<T1, T2, T3, T4, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2, T3, T4) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>
    let source3: Observable<T3>
    let source4: Observable<T4>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink4_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}



class CombineLatestSink5_<T1, T2, T3, T4, T5, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest5<T1, T2, T3, T4, T5, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil
    var observer3: CombineLatestObserver<T3>! = nil
    var observer4: CombineLatestObserver<T4>! = nil
    var observer5: CombineLatestObserver<T5>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 5, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(5)

        for i in 0 ..< 5 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])
        observer3 = CombineLatestObserver(parent: self, index: 3, this: subscriptions[3])
        observer4 = CombineLatestObserver(parent: self, index: 4, this: subscriptions[4])
        observer5 = CombineLatestObserver(parent: self, index: 5, this: subscriptions[5])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))
        subscriptions[3].setDisposable(*parent.source3.subscribeSafe(ObserverOf(observer3)))
        subscriptions[4].setDisposable(*parent.source4.subscribeSafe(ObserverOf(observer4)))
        subscriptions[5].setDisposable(*parent.source5.subscribeSafe(ObserverOf(observer5)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value, observer3.value, observer4.value, observer5.value)
    }
}

class CombineLatest5<T1, T2, T3, T4, T5, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2, T3, T4, T5) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>
    let source3: Observable<T3>
    let source4: Observable<T4>
    let source5: Observable<T5>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, source5: Observable<T5>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink5_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}



class CombineLatestSink6_<T1, T2, T3, T4, T5, T6, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest6<T1, T2, T3, T4, T5, T6, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil
    var observer3: CombineLatestObserver<T3>! = nil
    var observer4: CombineLatestObserver<T4>! = nil
    var observer5: CombineLatestObserver<T5>! = nil
    var observer6: CombineLatestObserver<T6>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 6, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(6)

        for i in 0 ..< 6 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])
        observer3 = CombineLatestObserver(parent: self, index: 3, this: subscriptions[3])
        observer4 = CombineLatestObserver(parent: self, index: 4, this: subscriptions[4])
        observer5 = CombineLatestObserver(parent: self, index: 5, this: subscriptions[5])
        observer6 = CombineLatestObserver(parent: self, index: 6, this: subscriptions[6])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))
        subscriptions[3].setDisposable(*parent.source3.subscribeSafe(ObserverOf(observer3)))
        subscriptions[4].setDisposable(*parent.source4.subscribeSafe(ObserverOf(observer4)))
        subscriptions[5].setDisposable(*parent.source5.subscribeSafe(ObserverOf(observer5)))
        subscriptions[6].setDisposable(*parent.source6.subscribeSafe(ObserverOf(observer6)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value, observer3.value, observer4.value, observer5.value, observer6.value)
    }
}

class CombineLatest6<T1, T2, T3, T4, T5, T6, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2, T3, T4, T5, T6) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>
    let source3: Observable<T3>
    let source4: Observable<T4>
    let source5: Observable<T5>
    let source6: Observable<T6>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, source5: Observable<T5>, source6: Observable<T6>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5
        self.source6 = source6

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink6_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}



class CombineLatestSink7_<T1, T2, T3, T4, T5, T6, T7, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest7<T1, T2, T3, T4, T5, T6, T7, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil
    var observer3: CombineLatestObserver<T3>! = nil
    var observer4: CombineLatestObserver<T4>! = nil
    var observer5: CombineLatestObserver<T5>! = nil
    var observer6: CombineLatestObserver<T6>! = nil
    var observer7: CombineLatestObserver<T7>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 7, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(7)

        for i in 0 ..< 7 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])
        observer3 = CombineLatestObserver(parent: self, index: 3, this: subscriptions[3])
        observer4 = CombineLatestObserver(parent: self, index: 4, this: subscriptions[4])
        observer5 = CombineLatestObserver(parent: self, index: 5, this: subscriptions[5])
        observer6 = CombineLatestObserver(parent: self, index: 6, this: subscriptions[6])
        observer7 = CombineLatestObserver(parent: self, index: 7, this: subscriptions[7])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))
        subscriptions[3].setDisposable(*parent.source3.subscribeSafe(ObserverOf(observer3)))
        subscriptions[4].setDisposable(*parent.source4.subscribeSafe(ObserverOf(observer4)))
        subscriptions[5].setDisposable(*parent.source5.subscribeSafe(ObserverOf(observer5)))
        subscriptions[6].setDisposable(*parent.source6.subscribeSafe(ObserverOf(observer6)))
        subscriptions[7].setDisposable(*parent.source7.subscribeSafe(ObserverOf(observer7)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value, observer3.value, observer4.value, observer5.value, observer6.value, observer7.value)
    }
}

class CombineLatest7<T1, T2, T3, T4, T5, T6, T7, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2, T3, T4, T5, T6, T7) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>
    let source3: Observable<T3>
    let source4: Observable<T4>
    let source5: Observable<T5>
    let source6: Observable<T6>
    let source7: Observable<T7>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, source5: Observable<T5>, source6: Observable<T6>, source7: Observable<T7>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5
        self.source6 = source6
        self.source7 = source7

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink7_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}



class CombineLatestSink8_<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest8<T1, T2, T3, T4, T5, T6, T7, T8, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil
    var observer3: CombineLatestObserver<T3>! = nil
    var observer4: CombineLatestObserver<T4>! = nil
    var observer5: CombineLatestObserver<T5>! = nil
    var observer6: CombineLatestObserver<T6>! = nil
    var observer7: CombineLatestObserver<T7>! = nil
    var observer8: CombineLatestObserver<T8>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 8, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(8)

        for i in 0 ..< 8 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])
        observer3 = CombineLatestObserver(parent: self, index: 3, this: subscriptions[3])
        observer4 = CombineLatestObserver(parent: self, index: 4, this: subscriptions[4])
        observer5 = CombineLatestObserver(parent: self, index: 5, this: subscriptions[5])
        observer6 = CombineLatestObserver(parent: self, index: 6, this: subscriptions[6])
        observer7 = CombineLatestObserver(parent: self, index: 7, this: subscriptions[7])
        observer8 = CombineLatestObserver(parent: self, index: 8, this: subscriptions[8])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))
        subscriptions[3].setDisposable(*parent.source3.subscribeSafe(ObserverOf(observer3)))
        subscriptions[4].setDisposable(*parent.source4.subscribeSafe(ObserverOf(observer4)))
        subscriptions[5].setDisposable(*parent.source5.subscribeSafe(ObserverOf(observer5)))
        subscriptions[6].setDisposable(*parent.source6.subscribeSafe(ObserverOf(observer6)))
        subscriptions[7].setDisposable(*parent.source7.subscribeSafe(ObserverOf(observer7)))
        subscriptions[8].setDisposable(*parent.source8.subscribeSafe(ObserverOf(observer8)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value, observer3.value, observer4.value, observer5.value, observer6.value, observer7.value, observer8.value)
    }
}

class CombineLatest8<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2, T3, T4, T5, T6, T7, T8) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>
    let source3: Observable<T3>
    let source4: Observable<T4>
    let source5: Observable<T5>
    let source6: Observable<T6>
    let source7: Observable<T7>
    let source8: Observable<T8>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, source5: Observable<T5>, source6: Observable<T6>, source7: Observable<T7>, source8: Observable<T8>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5
        self.source6 = source6
        self.source7 = source7
        self.source8 = source8

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink8_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}



class CombineLatestSink9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest9<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil
    var observer3: CombineLatestObserver<T3>! = nil
    var observer4: CombineLatestObserver<T4>! = nil
    var observer5: CombineLatestObserver<T5>! = nil
    var observer6: CombineLatestObserver<T6>! = nil
    var observer7: CombineLatestObserver<T7>! = nil
    var observer8: CombineLatestObserver<T8>! = nil
    var observer9: CombineLatestObserver<T9>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 9, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(9)

        for i in 0 ..< 9 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])
        observer3 = CombineLatestObserver(parent: self, index: 3, this: subscriptions[3])
        observer4 = CombineLatestObserver(parent: self, index: 4, this: subscriptions[4])
        observer5 = CombineLatestObserver(parent: self, index: 5, this: subscriptions[5])
        observer6 = CombineLatestObserver(parent: self, index: 6, this: subscriptions[6])
        observer7 = CombineLatestObserver(parent: self, index: 7, this: subscriptions[7])
        observer8 = CombineLatestObserver(parent: self, index: 8, this: subscriptions[8])
        observer9 = CombineLatestObserver(parent: self, index: 9, this: subscriptions[9])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))
        subscriptions[3].setDisposable(*parent.source3.subscribeSafe(ObserverOf(observer3)))
        subscriptions[4].setDisposable(*parent.source4.subscribeSafe(ObserverOf(observer4)))
        subscriptions[5].setDisposable(*parent.source5.subscribeSafe(ObserverOf(observer5)))
        subscriptions[6].setDisposable(*parent.source6.subscribeSafe(ObserverOf(observer6)))
        subscriptions[7].setDisposable(*parent.source7.subscribeSafe(ObserverOf(observer7)))
        subscriptions[8].setDisposable(*parent.source8.subscribeSafe(ObserverOf(observer8)))
        subscriptions[9].setDisposable(*parent.source9.subscribeSafe(ObserverOf(observer9)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value, observer3.value, observer4.value, observer5.value, observer6.value, observer7.value, observer8.value, observer9.value)
    }
}

class CombineLatest9<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2, T3, T4, T5, T6, T7, T8, T9) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>
    let source3: Observable<T3>
    let source4: Observable<T4>
    let source5: Observable<T5>
    let source6: Observable<T6>
    let source7: Observable<T7>
    let source8: Observable<T8>
    let source9: Observable<T9>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, source5: Observable<T5>, source6: Observable<T6>, source7: Observable<T7>, source8: Observable<T8>, source9: Observable<T9>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5
        self.source6 = source6
        self.source7 = source7
        self.source8 = source8
        self.source9 = source9

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink9_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}



class CombineLatestSink10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : CombineLatestSink<TResult> {
    typealias Parent = CombineLatest10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>

    let parent: Parent

    var observer1: CombineLatestObserver<T1>! = nil
    var observer2: CombineLatestObserver<T2>! = nil
    var observer3: CombineLatestObserver<T3>! = nil
    var observer4: CombineLatestObserver<T4>! = nil
    var observer5: CombineLatestObserver<T5>! = nil
    var observer6: CombineLatestObserver<T6>! = nil
    var observer7: CombineLatestObserver<T7>! = nil
    var observer8: CombineLatestObserver<T8>! = nil
    var observer9: CombineLatestObserver<T9>! = nil
    var observer10: CombineLatestObserver<T10>! = nil

    init(parent: Parent, observer: ObserverOf<TResult>, cancel: Disposable) {
        self.parent = parent
        super.init(arity: 10, observer: observer, cancel: cancel)
    }

    func run() -> Result<Disposable> {
        var subscriptions: [SingleAssignmentDisposable] = []
        subscriptions.reserveCapacity(10)

        for i in 0 ..< 10 {
            subscriptions.append(SingleAssignmentDisposable())
        }

        observer1 = CombineLatestObserver(parent: self, index: 1, this: subscriptions[1])
        observer2 = CombineLatestObserver(parent: self, index: 2, this: subscriptions[2])
        observer3 = CombineLatestObserver(parent: self, index: 3, this: subscriptions[3])
        observer4 = CombineLatestObserver(parent: self, index: 4, this: subscriptions[4])
        observer5 = CombineLatestObserver(parent: self, index: 5, this: subscriptions[5])
        observer6 = CombineLatestObserver(parent: self, index: 6, this: subscriptions[6])
        observer7 = CombineLatestObserver(parent: self, index: 7, this: subscriptions[7])
        observer8 = CombineLatestObserver(parent: self, index: 8, this: subscriptions[8])
        observer9 = CombineLatestObserver(parent: self, index: 9, this: subscriptions[9])
        observer10 = CombineLatestObserver(parent: self, index: 10, this: subscriptions[10])

        subscriptions[1].setDisposable(*parent.source1.subscribeSafe(ObserverOf(observer1)))
        subscriptions[2].setDisposable(*parent.source2.subscribeSafe(ObserverOf(observer2)))
        subscriptions[3].setDisposable(*parent.source3.subscribeSafe(ObserverOf(observer3)))
        subscriptions[4].setDisposable(*parent.source4.subscribeSafe(ObserverOf(observer4)))
        subscriptions[5].setDisposable(*parent.source5.subscribeSafe(ObserverOf(observer5)))
        subscriptions[6].setDisposable(*parent.source6.subscribeSafe(ObserverOf(observer6)))
        subscriptions[7].setDisposable(*parent.source7.subscribeSafe(ObserverOf(observer7)))
        subscriptions[8].setDisposable(*parent.source8.subscribeSafe(ObserverOf(observer8)))
        subscriptions[9].setDisposable(*parent.source9.subscribeSafe(ObserverOf(observer9)))
        subscriptions[10].setDisposable(*parent.source10.subscribeSafe(ObserverOf(observer10)))

        return success(CompositeDisposable(disposables: subscriptions))
    }

    override func getResult() -> Result<TResult> {
        return self.parent.resultSelector(observer1.value, observer2.value, observer3.value, observer4.value, observer5.value, observer6.value, observer7.value, observer8.value, observer9.value, observer10.value)
    }
}

class CombineLatest10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : Producer<TResult> {
    typealias ResultSelector = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) -> Result<TResult>

    let source1: Observable<T1>
    let source2: Observable<T2>
    let source3: Observable<T3>
    let source4: Observable<T4>
    let source5: Observable<T5>
    let source6: Observable<T6>
    let source7: Observable<T7>
    let source8: Observable<T8>
    let source9: Observable<T9>
    let source10: Observable<T10>

    let resultSelector: ResultSelector

    init(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, source5: Observable<T5>, source6: Observable<T6>, source7: Observable<T7>, source8: Observable<T8>, source9: Observable<T9>, source10: Observable<T10>, resultSelector: ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5
        self.source6 = source6
        self.source7 = source7
        self.source8 = source8
        self.source9 = source9
        self.source10 = source10

        self.resultSelector = resultSelector
    }

    override func run(observer: ObserverOf<TResult>, cancel: Disposable, setSink: (Disposable) -> Void) -> Result<Disposable> {
        let sink = CombineLatestSink10_(parent: self, observer: observer, cancel: cancel)
        setSink(sink)
        return sink.run()
    }
}

